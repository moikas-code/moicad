/**
 * Export API Handler
 *
 * POST /api/export
 *
 * Exports geometry to STL or OBJ format.
 * Implementation matches apps/landing/app/api/export/route.ts for parity.
 */

import { logger } from '../utils/logger';

interface Geometry {
  vertices: number[] | Float32Array;
  indices: number[] | Uint32Array;
  normals: number[] | Float32Array;
  stats?: {
    vertexCount?: number;
    faceCount?: number;
    volume?: number;
  };
}

interface ExportRequest {
  geometry: Geometry;
  format: 'stl' | 'obj';
}

// STL export implementation using geometry data
function exportToSTL(geometry: Geometry): ArrayBuffer {
  const vertices = Array.isArray(geometry.vertices)
    ? new Float32Array(geometry.vertices)
    : geometry.vertices;

  const indices = Array.isArray(geometry.indices)
    ? new Uint32Array(geometry.indices)
    : geometry.indices;

  const normals = Array.isArray(geometry.normals)
    ? new Float32Array(geometry.normals)
    : geometry.normals;

  // STL binary format (80-byte header + 4-byte triangle count + 50 bytes per triangle)
  const triangleCount = indices.length / 3;
  const buffer = new ArrayBuffer(80 + 4 + triangleCount * 50);
  const view = new DataView(buffer);

  // Write triangle count
  view.setUint32(80, triangleCount, true);

  // Write triangles
  for (let i = 0; i < indices.length; i += 3) {
    const offset = 84 + (i / 3) * 50;

    // Get face vertices
    const i1 = indices[i] * 3;
    const i2 = indices[i + 1] * 3;
    const i3 = indices[i + 2] * 3;

    // Calculate face normal (simplified - assumes vertices are already normalized)
    const n1 = normals[i1];
    const n2 = normals[i1 + 1];
    const n3 = normals[i1 + 2];

    // Normal vector
    view.setFloat32(offset, n1, true);
    view.setFloat32(offset + 4, n2, true);
    view.setFloat32(offset + 8, n3, true);

    // Vertex 1
    view.setFloat32(offset + 12, vertices[i1], true);
    view.setFloat32(offset + 16, vertices[i1 + 1], true);
    view.setFloat32(offset + 20, vertices[i1 + 2], true);

    // Vertex 2
    view.setFloat32(offset + 24, vertices[i2], true);
    view.setFloat32(offset + 28, vertices[i2 + 1], true);
    view.setFloat32(offset + 32, vertices[i2 + 2], true);

    // Vertex 3
    view.setFloat32(offset + 36, vertices[i3], true);
    view.setFloat32(offset + 40, vertices[i3 + 1], true);
    view.setFloat32(offset + 44, vertices[i3 + 2], true);

    // Attribute byte count (must be 0)
    view.setUint16(offset + 48, 0, true);
  }

  return buffer;
}

// OBJ export implementation using geometry data
function exportToOBJ(geometry: Geometry): string {
  const vertices = Array.isArray(geometry.vertices)
    ? geometry.vertices
    : Array.from(geometry.vertices);

  const indices = Array.isArray(geometry.indices)
    ? geometry.indices
    : Array.from(geometry.indices);

  let obj = '# Generated by @moicad/cli\n';
  obj += '# Vertices\n\n';

  // Write vertices
  for (let i = 0; i < vertices.length; i += 3) {
    obj += `v ${vertices[i]} ${vertices[i + 1]} ${vertices[i + 2]}\n`;
  }

  obj += '\n# Faces\n';

  // Write faces (1-indexed for OBJ format)
  for (let i = 0; i < indices.length; i += 3) {
    obj += `f ${indices[i] + 1} ${indices[i + 1] + 1} ${indices[i + 2] + 1}\n`;
  }

  return obj;
}

export async function handleExport(req: Request): Promise<Response> {
  try {
    const body: ExportRequest = await req.json();
    const { geometry, format } = body;

    // Validate required fields
    if (!geometry || !format) {
      return new Response(
        JSON.stringify({ error: 'Missing geometry or format parameter', success: false }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Validate format
    if (!['stl', 'obj'].includes(format)) {
      return new Response(
        JSON.stringify({ error: 'Unsupported format. Use "stl" or "obj"', success: false }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Validate geometry has required fields
    if (!geometry.vertices || !geometry.indices) {
      return new Response(
        JSON.stringify({ error: 'Invalid geometry: missing vertices or indices', success: false }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    if (format === 'stl') {
      // Ensure normals exist for STL export
      if (!geometry.normals) {
        return new Response(
          JSON.stringify({ error: 'Invalid geometry: missing normals for STL export', success: false }),
          { status: 400, headers: { 'Content-Type': 'application/json' } }
        );
      }

      const stlBuffer = exportToSTL(geometry);
      return new Response(stlBuffer, {
        status: 200,
        headers: {
          'Content-Type': 'application/octet-stream',
          'Content-Disposition': 'attachment; filename="model.stl"',
          'Content-Length': stlBuffer.byteLength.toString(),
        },
      });
    } else {
      const objString = exportToOBJ(geometry);
      return new Response(objString, {
        status: 200,
        headers: {
          'Content-Type': 'model/obj',
          'Content-Disposition': 'attachment; filename="model.obj"',
          'Content-Length': objString.length.toString(),
        },
      });
    }

  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown export error';
    logger.error(`Export error: ${message}`);

    return new Response(
      JSON.stringify({ error: message, success: false }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}
