import { NextRequest } from 'next/server';
import { GeometrySchema } from '@moicad/sdk';
import { Geometry } from '@moicad/sdk';

// STL export implementation using geometry data
function exportToSTL(geometry: Geometry): ArrayBuffer {
  const vertices = Array.isArray(geometry.vertices)
    ? new Float32Array(geometry.vertices)
    : geometry.vertices;

  const indices = Array.isArray(geometry.indices)
    ? new Uint32Array(geometry.indices)
    : geometry.indices;

  const normals = Array.isArray(geometry.normals)
    ? new Float32Array(geometry.normals)
    : geometry.normals;

  // STL binary format (80-byte header + 4-byte triangle count + 50 bytes per triangle)
  const triangleCount = indices.length / 3;
  const buffer = new ArrayBuffer(80 + 4 + triangleCount * 50);
  const view = new DataView(buffer);

  // Write triangle count
  view.setUint32(80, triangleCount, true);

  // Write triangles
  for (let i = 0; i < indices.length; i += 3) {
    const offset = 84 + (i / 3) * 50;

    // Get face vertices
    const i1 = indices[i] * 3;
    const i2 = indices[i + 1] * 3;
    const i3 = indices[i + 2] * 3;

    // Calculate face normal (simplified - assumes vertices are already normalized)
    const n1 = normals[i1];
    const n2 = normals[i1 + 1];
    const n3 = normals[i1 + 2];

    // Normal vector
    view.setFloat32(offset, n1, true);
    view.setFloat32(offset + 4, n2, true);
    view.setFloat32(offset + 8, n3, true);

    // Vertex 1
    view.setFloat32(offset + 12, vertices[i1], true);
    view.setFloat32(offset + 16, vertices[i1 + 1], true);
    view.setFloat32(offset + 20, vertices[i1 + 2], true);

    // Vertex 2
    view.setFloat32(offset + 24, vertices[i2], true);
    view.setFloat32(offset + 28, vertices[i2 + 1], true);
    view.setFloat32(offset + 32, vertices[i2 + 2], true);

    // Vertex 3
    view.setFloat32(offset + 36, vertices[i3], true);
    view.setFloat32(offset + 40, vertices[i3 + 1], true);
    view.setFloat32(offset + 44, vertices[i3 + 2], true);

    // Attribute byte count (must be 0)
    view.setUint16(offset + 48, 0, true);
  }

  return buffer;
}

// OBJ export implementation using geometry data
function exportToOBJ(geometry: Geometry): string {
  const vertices = Array.isArray(geometry.vertices)
    ? geometry.vertices
    : Array.from(geometry.vertices);

  const indices = Array.isArray(geometry.indices)
    ? geometry.indices
    : Array.from(geometry.indices);

  let obj = '# Generated by @moicad/sdk\n';
  obj += '# Vertices\n\n';

  // Write vertices
  for (let i = 0; i < vertices.length; i += 3) {
    obj += `v ${vertices[i]} ${vertices[i + 1]} ${vertices[i + 2]}\n`;
  }

  obj += '\n# Faces\n';

  // Write faces (1-indexed for OBJ format)
  for (let i = 0; i < indices.length; i += 3) {
    obj += `f ${indices[i] + 1} ${indices[i + 1] + 1} ${indices[i + 2] + 1}\n`;
  }

  return obj;
}

export async function POST(request: NextRequest) {
  try {
    const { geometry, format } = await request.json();

    if (!geometry || !format) {
      return Response.json({
        error: 'Missing geometry or format parameter',
        success: false
      }, { status: 400 });
    }

    if (!['stl', 'obj'].includes(format)) {
      return Response.json({
        error: 'Unsupported format. Use "stl" or "obj"',
        success: false
      }, { status: 400 });
    }

    // Validate geometry with Zod schema
    const validatedGeometry = GeometrySchema.parse(geometry);

    // Ensure stats has required fields
    if (!validatedGeometry.stats?.vertexCount || !validatedGeometry.stats?.faceCount) {
      // Calculate stats if missing
      const vertices = Array.isArray(validatedGeometry.vertices)
        ? validatedGeometry.vertices
        : Array.from(validatedGeometry.vertices);
      const indices = Array.isArray(validatedGeometry.indices)
        ? validatedGeometry.indices
        : Array.from(validatedGeometry.indices);

      validatedGeometry.stats = {
        vertexCount: vertices.length / 3,
        faceCount: indices.length / 3,
        volume: validatedGeometry.stats?.volume ?? 0
      };
    }

    if (format === 'stl') {
      const stlBuffer = exportToSTL(validatedGeometry as Geometry);
      return new Response(stlBuffer, {
        headers: {
          'Content-Type': 'application/octet-stream',
          'Content-Disposition': 'attachment; filename="model.stl"',
          'Content-Length': stlBuffer.byteLength.toString()
        }
      });
    } else if (format === 'obj') {
      const objString = exportToOBJ(validatedGeometry as Geometry);
      return new Response(objString, {
        headers: {
          'Content-Type': 'model/obj',
          'Content-Disposition': 'attachment; filename="model.obj"',
          'Content-Length': objString.length.toString()
        }
      });
    }

  } catch (error) {
    console.error('Export API error:', error);

    if (error instanceof Error) {
      if (error.message.includes('validation')) {
        return Response.json({
          error: 'Invalid geometry format',
          success: false
        }, { status: 400 });
      }

      return Response.json({
        error: error.message,
        success: false
      }, { status: 500 });
    }

    return Response.json({
      error: 'Internal server error',
      success: false
    }, { status: 500 });
  }
}

export const dynamic = 'force-dynamic';
export const maxDuration = 30;
export const runtime = 'nodejs';
